---
import type { JSX } from "astro/jsx-runtime";
import { Icon } from "astro-icon/components";
import { InvalidAnchorFormatError } from "../../../utils/exceptions";
import Button from "../../atoms/button/button.astro";

type Props = JSX.HTMLAttributes & {
  /**
   * An anchor on the same page.
   */
  anchor: `#${string}`;
  /**
   * A visually hidden label.
   */
  label: string;
  /**
   * From which position on the page the button should be displayed.
   */
  scrollThreshold?: number | null | undefined;
};

const {
  anchor,
  class: className,
  label,
  scrollThreshold,
  slot,
  ...attrs
} = Astro.props;

if (!anchor.startsWith("#")) {
  throw new InvalidAnchorFormatError("anchor", anchor);
}
---

<back-to-top
  {...attrs}
  class:list={[className, "back-to-top"]}
  data-threshold={scrollThreshold}
  data-visible="false"
>
  <Button as="a" href={anchor}>
    <Icon aria-hidden="true" name="caret-top" />
    <span class="sr-only">{label}</span>
  </Button>
</back-to-top>

<style>
  @layer components {
    .back-to-top {
      &[data-visible="false"] {
        opacity: 0;
        visibility: hidden;
        transition:
          opacity 0.3s ease-in-out 0s,
          visibility 0s ease-in-out 0.3s;
      }

      &[data-visible="true"] {
        opacity: 1;
        visibility: visible;
        transition:
          opacity 0.3s ease-in 0s,
          visibility 0s ease-in 0s;
      }
    }

    .back-to-top > a {
      aspect-ratio: 1 / 1;
      border-width: var(--border-size-md);
      box-shadow: var(--shadow-elevated-to-top-left);

      @media (any-pointer: fine) {
        padding: var(--spacing-sm);
      }

      &:is(:hover, :focus) {
        box-shadow: var(--shadow-floating-to-top-left);
        transform: scale(1.095);
      }

      &:is(:active) {
        box-shadow: var(--shadow-raised-to-top-left);
        transform: scale(0.95);
      }
    }
  }
</style>

<script>
  class BackToTop extends HTMLElement {
    #threshold: number;

    constructor() {
      super();
      this.#threshold = parseInt(this.dataset.threshold || "300", 10);
      this.updateVisibility = this.updateVisibility.bind(this);
    }

    connectedCallback() {
      this.updateVisibility();
      window.addEventListener("scroll", this.updateVisibility);
    }

    disconnectedCallback() {
      window.removeEventListener("scroll", this.updateVisibility);
    }

    updateVisibility() {
      const shouldBeVisible = window.scrollY >= this.#threshold;
      const isCurrentlyVisible = this.getAttribute("data-visible") === "true";

      if (shouldBeVisible !== isCurrentlyVisible) {
        this.setAttribute("data-visible", shouldBeVisible ? "true" : "false");
      }
    }
  }

  customElements.define("back-to-top", BackToTop);
</script>
