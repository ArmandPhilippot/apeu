---
import type { JSX } from "astro/jsx-runtime";
import type { ComponentProps } from "astro/types";
import { SETTING_KEYS, type Settings } from "../../../services/stores";
import type { Theme } from "../../../types/tokens";
import { isKeyExistIn } from "../../../utils/type-guards";
import Label from "../../atoms/label/label.astro";
import SelectField from "../../atoms/select-field/select-field.astro";
import Select from "../select/select.astro";

type Themes = Record<Theme, string>;

type Props = JSX.HTMLAttributes &
  Pick<ComponentProps<typeof Select>, "hideLabel" | "label"> & {
    /**
     * The current theme.
     */
    current: Theme;
    /**
     * The controlled setting key.
     */
    setting?: keyof Settings | null | undefined;
    /**
     * Should we add an icon in front of the field?
     *
     * @default false
     */
    showIcon?: boolean | null | undefined;
    /**
     * An object with the theme as key associated to a label.
     */
    themes: Themes;
  };

const {
  class: className,
  current,
  hideLabel,
  label,
  setting = SETTING_KEYS.THEME,
  showIcon = false,
  slot,
  themes,
  ...attrs
} = Astro.props;
const options: ComponentProps<typeof Select>["options"] = Object.entries(
  themes
).map(([theme, themeLabel]) => {
  return { label: themeLabel, value: theme };
});
const isValidTheme = isKeyExistIn(themes, current);

if (!isValidTheme) {
  throw new Error(
    `The provided value for "current" does not match any "themes" key. Received: ${current}`
  );
}
---

<ap-theme-select
  {...attrs}
  class:list={["theme-select", className]}
  data-setting={setting}
>
  <Label>
    <span class:list={{ "sr-only": hideLabel }}>{label}</span>
    <SelectField
      icon={/* TODO: replace the icon */
      showIcon ? "locale" : null}
      options={options}
      value={current}
    />
  </Label>
</ap-theme-select>

<style>
  .theme-select,
  .theme-select label {
    display: flex;
    flex-flow: row wrap;
  }

  .theme-select label > *:last-child {
    flex: 1;
  }
</style>

<script>
  import {
    isValidSettingsKey,
    SETTING_KEYS,
    settings,
    type Settings,
  } from "../../../services/stores";
  import { isValidTheme } from "../../../utils/type-guards";

  class APThemeSelect extends HTMLElement {
    #select: HTMLSelectElement | null = null;
    #settingKey: keyof Settings = SETTING_KEYS.THEME;
    #unsubscribe: (() => void) | null = null;

    constructor() {
      super();
      this.handleThemeChange = this.handleThemeChange.bind(this);
    }

    connectedCallback() {
      this.#select = this.querySelector("select");
      this.#select?.addEventListener("change", this.handleThemeChange);

      if (isValidSettingsKey(this.dataset.setting)) {
        this.#settingKey = this.dataset.setting;
      }
    }

    disconnectedCallback() {
      this.#select?.removeEventListener("change", this.handleThemeChange);

      if (this.#unsubscribe) {
        this.#unsubscribe();
      }
    }

    handleThemeChange(e: Event) {
      if (!(e.currentTarget instanceof HTMLSelectElement)) return;

      e.stopImmediatePropagation();

      const newTheme = isValidTheme(e.currentTarget.value)
        ? e.currentTarget.value
        : null;

      if (newTheme === null) return;

      if (this.#select) {
        this.#select.value = newTheme;
        settings.setKey(this.#settingKey, newTheme);
      }
    }
  }

  customElements.define("ap-theme-select", APThemeSelect);
</script>
