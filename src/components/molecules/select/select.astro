---
import type { ComponentProps } from "astro/types";
import { Icon } from "astro-icon/components";
import type { IconName } from "../../../types/tokens";
import Label from "../../atoms/label/label.astro";

type Option = {
  label: string;
  value: string;
};

type Props = Omit<ComponentProps<typeof Label>, "children"> & {
  hideLabel?: boolean | null | undefined;
  icon?: IconName | null | undefined;
  /**
   * The icon size when defined.
   *
   * @default 24
   */
  iconSize?: number | undefined;
  label: string;
  options: Option[];
  value: string;
};

const {
  class: className,
  hideLabel = false,
  icon,
  iconSize = 24,
  isRequired = false,
  label,
  options,
  slot,
  value,
  ...attrs
} = Astro.props;
const currentOption = options.find((option) => option.value === value);

if (!currentOption) {
  throw new Error(
    `The provided value does not match any value in your "options". Received: ${value}`
  );
}
---

<Label {...attrs} class:list={["select", className]} isRequired={isRequired}>
  {icon ? <Icon aria-hidden name={icon} size={iconSize} /> : null}
  <span class:list={{ "sr-only": hideLabel }}>{label}</span>
  <select autocomplete="off" required={isRequired} value={value}>
    {
      options.map((option) => (
        <option selected={option.value === value} value={option.value}>
          {option.label}
        </option>
      ))
    }
  </select>
</Label>

<style define:vars={{ "icon-size": iconSize }}>
  .select {
    display: flex;
    flex-flow: row wrap;
    align-items: center;
    gap: var(--spacing-xs) var(--spacing-3xs);
    width: fit-content;
  }

  select {
    padding: var(--spacing-xs);
    color: inherit;
    text-overflow: ellipsis;
  }

  option {
    background: var(--color-regular-light);
    color: var(--color-on-regular);
  }

  .select:has(.sr-only),
  :where(.select:not(:has(.sr-only))) select {
    background: var(--color-regular-dark);
    border: var(--border-size-sm) solid var(--color-border);
    border-radius: var(--border-radii-md);
    box-shadow: var(--shadow-raised-to-top-left);
    cursor: pointer;
  }

  :where(.select:not(:has(.sr-only))) select {
    margin-inline-start: var(--spacing-2xs);
    padding-inline: var(--spacing-xs);
  }

  :where(.select:has(.sr-only)) svg {
    margin-inline-start: var(--spacing-xs);
  }

  :where(.select:has(.sr-only):has(svg)) select {
    flex: 1;
    margin-inline-start: calc(var(--icon-size) * var(--one-px-in-rem) * -1.5);
    padding-inline-start: calc(
      var(--icon-size) * var(--one-px-in-rem) * 1.5 + var(--spacing-4xs)
    );
  }

  :where(.select:has(.sr-only)) select {
    background: none;
    border: none;
    cursor: pointer;
    font-weight: var(--font-weight-bold);
    outline: none;

    &:focus {
      color: var(--color-primary-dark);
    }
  }

  .select:has(.sr-only):focus-within,
  :where(.select:not(:has(.sr-only))) select:focus {
    outline: var(--color-primary) solid var(--border-size-md);
  }
</style>
