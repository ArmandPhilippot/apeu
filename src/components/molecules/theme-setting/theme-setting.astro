---
import type { JSX } from "astro/jsx-runtime";
import type { ComponentProps } from "astro/types";
import { useI18n } from "../../../services/i18n";
import {
  getSettingDefault,
  resolveCurrentColorScheme,
  type Settings,
} from "../../../services/stores";
import type { Theme } from "../../../types/tokens";
import Switch from "../switch/switch.astro";
import Toggle from "../toggle/toggle.astro";

type Props = JSX.HTMLAttributes & {
  /**
   * Should the legend be inlined with the options?
   *
   * @default false
   */
  isInline?: boolean | null | undefined;
  /**
   * The options legend.
   */
  label: string;
  /**
   * The controlled setting key.
   */
  setting: keyof Settings;
  /**
   * The form control variant.
   *
   * @default "toggle"
   */
  variant?: "switch" | "toggle" | undefined;
};

const {
  class: className,
  id,
  isInline = false,
  label,
  setting,
  variant = "toggle",
  ...attrs
} = Astro.props;
const { translate } = useI18n(Astro.currentLocale);
const idPrefix = id ? `${id}-` : "";
const settingPrefix = `${setting}-`;
const switchThemes = [
  {
    icon: "sun",
    label: translate("theme.label.light"),
    value: "light",
  },
  {
    icon: "moon",
    label: translate("theme.label.dark"),
    value: "dark",
  },
] satisfies ComponentProps<typeof Switch>["items"];
const toggleThemes = [
  {
    id: `${idPrefix}${settingPrefix}auto`,
    label: translate("theme.label.auto"),
    value: "auto" satisfies Theme,
  },
  {
    id: `${idPrefix}${settingPrefix}dark`,
    label: translate("theme.label.dark"),
    value: "dark" satisfies Theme,
  },
  {
    id: `${idPrefix}${settingPrefix}light`,
    label: translate("theme.label.light"),
    value: "light" satisfies Theme,
  },
] satisfies ComponentProps<typeof Toggle>["items"];
const defaultValue = getSettingDefault(setting);
---

<ap-theme-setting
  {...attrs}
  class:list={["theme-setting", className]}
  data-setting={setting}
  data-variant={variant}
  id={id}
>
  {
    variant === "switch" ? (
      <Switch
        hideItemsLabel
        hideLabel
        isInline={isInline}
        items={switchThemes}
        label={label}
        value={resolveCurrentColorScheme(defaultValue)}
      />
    ) : (
      <Toggle
        groupName={`${idPrefix}${setting}`}
        isInline={isInline}
        items={toggleThemes}
        label={label}
        value={defaultValue}
      />
    )
  }
</ap-theme-setting>

<style>
  .theme-setting {
    display: block;
  }
</style>

<script>
  import {
    isValidSettingsKey,
    resolveCurrentColorScheme,
    SETTING_KEYS,
    settings,
    type Settings,
  } from "../../../services/stores";
  import type { Theme } from "../../../types/tokens";
  import { isValidTheme } from "../../../utils/type-guards";

  class APThemeSetting extends HTMLElement {
    #isSwitch = false;
    #settingKey: keyof Settings = SETTING_KEYS.THEME;
    #switchBtn: HTMLButtonElement | null = null;
    #unsubscribe: (() => void) | null = null;

    constructor() {
      super();
      this.handleUpdate = this.handleUpdate.bind(this);
    }

    connectedCallback() {
      this.#isSwitch = this.dataset.variant === "switch";
      this.#switchBtn = this.querySelector("button");

      if (isValidSettingsKey(this.dataset.setting)) {
        this.#settingKey = this.dataset.setting;
      }

      this.#unsubscribe = settings.subscribe(
        (newSettings: Readonly<Settings>) => {
          this.#updateSelectedTheme(newSettings);
        }
      );

      if (this.#isSwitch) {
        this.#switchBtn?.addEventListener("click", this.handleUpdate, {
          capture: true,
        });
      } else {
        this.addEventListener("change", this.handleUpdate);
      }
    }

    disconnectedCallback() {
      if (this.#isSwitch) {
        this.#switchBtn?.removeEventListener("click", this.handleUpdate, {
          capture: true,
        });
      } else {
        this.removeEventListener("change", this.handleUpdate);
      }

      // Unsubscribe from store
      if (this.#unsubscribe) {
        this.#unsubscribe();
      }
    }

    #updateSwitchValue(newSettings: Readonly<Settings>) {
      if (!this.#switchBtn) return;

      const newTheme = newSettings[this.#settingKey];
      const themeToResolve =
        this.#settingKey === SETTING_KEYS.SHIKI && newTheme === "auto"
          ? newSettings.theme
          : newTheme;
      const theme = resolveCurrentColorScheme(themeToResolve);

      this.#switchBtn.ariaChecked = String(theme === "dark");
    }

    #updateToggleValue(newSettings: Readonly<Settings>) {
      const newOption = this.querySelector<HTMLInputElement>(
        `input[value="${newSettings[this.#settingKey]}"]`
      );

      if (newOption) newOption.checked = true;
    }

    #updateSelectedTheme(newSettings: Readonly<Settings>) {
      if (this.#isSwitch) this.#updateSwitchValue(newSettings);
      else this.#updateToggleValue(newSettings);
    }

    #getSelectedToggleTheme(option: HTMLInputElement): Theme | null {
      if (isValidTheme(option.value)) return option.value;
      return null;
    }

    #getUnselectedSwitchTheme(btn: HTMLButtonElement) {
      return btn.ariaChecked === "true" ? "light" : "dark";
    }

    handleUpdate(e: Event) {
      e.stopImmediatePropagation();

      const newTheme = this.#getNewThemeFromEvent(e);

      if (newTheme === null) return;

      settings.setKey(this.#settingKey, newTheme);
    }

    #getNewThemeFromEvent(e: Event): Theme | null {
      if (this.#isSwitch && e.currentTarget instanceof HTMLButtonElement) {
        return this.#getUnselectedSwitchTheme(e.currentTarget);
      }

      if (e.target instanceof HTMLInputElement) {
        return this.#getSelectedToggleTheme(e.target);
      }

      return null;
    }
  }

  customElements.define("ap-theme-setting", APThemeSetting);
</script>
